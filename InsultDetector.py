# Before use, first run:
# pip install numpy scipy matplotlib PyQt5 pylsl scikit-learn
# This Python code is generated by ChatGPT. It needs testing.
import sys
import numpy as np
import time
import json
from scipy.signal import butter, lfilter
from PyQt5.QtWidgets import QMainWindow, QApplication, QVBoxLayout, QPushButton, QWidget, QLabel, QFileDialog
from PyQt5.QtCore import Qt, QThread, pyqtSignal, pyqtSlot
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from pylsl import StreamInlet, resolve_stream
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier


class DataCollector(QThread):
    data_collected = pyqtSignal(np.ndarray)

    def __init__(self, sampling_rate):
        super().__init__()
        self.sampling_rate = sampling_rate
        self.inlet = None
        self.stop_signal = False

    def run(self):
        print("Looking for an EEG stream...")
        streams = resolve_stream('type', 'EEG')
        self.inlet = StreamInlet(streams[0])
        print("Stream found. Collecting data...")

        eeg_data = []
        start_time = time.time()
        while time.time() - start_time < 10 and not self.stop_signal:
            sample, _ = self.inlet.pull_sample()
            eeg_data.append(sample)

        self.data_collected.emit(np.array(eeg_data))

    def stop(self):
        self.stop_signal = True


class InsultDetector(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("EEG Data Labeling Tool")
        self.setGeometry(100, 100, 800, 600)

        # Data attributes
        self.eeg_data = []
        self.sampling_rate = 256  # Example sampling rate
        self.labels = []
        self.model = None
        self.data_collector = None

        # Main Widget
        self.main_widget = QWidget(self)
        self.setCentralWidget(self.main_widget)

        # Layout
        layout = QVBoxLayout(self.main_widget)

        # Matplotlib Figure and Canvas
        self.fig, self.ax = plt.subplots()
        self.canvas = FigureCanvas(self.fig)
        layout.addWidget(self.canvas)

        # Control Buttons
        self.start_record_button = QPushButton("Start Recording", self)
        self.start_record_button.clicked.connect(self.start_recording)
        layout.addWidget(self.start_record_button)

        self.stop_record_button = QPushButton("Stop Recording", self)
        self.stop_record_button.clicked.connect(self.stop_recording)
        layout.addWidget(self.stop_record_button)

        self.save_button = QPushButton("Save Data", self)
        self.save_button.clicked.connect(self.save_data)
        layout.addWidget(self.save_button)

        self.load_button = QPushButton("Load Data", self)
        self.load_button.clicked.connect(self.load_data)
        layout.addWidget(self.load_button)

        self.label_start_button = QPushButton("Label Start", self)
        self.label_start_button.clicked.connect(self.label_start)
        layout.addWidget(self.label_start_button)

        self.label_end_button = QPushButton("Label End", self)
        self.label_end_button.clicked.connect(self.label_end)
        layout.addWidget(self.label_end_button)

        self.train_button = QPushButton("Train Model", self)
        self.train_button.clicked.connect(self.train_model)
        layout.addWidget(self.train_button)

        self.detect_button = QPushButton("Start Real-Time Detection", self)
        self.detect_button.clicked.connect(self.start_real_time_detection)
        layout.addWidget(self.detect_button)

        self.stop_detect_button = QPushButton("Stop Real-Time Detection", self)
        self.stop_detect_button.clicked.connect(self.stop_real_time_detection)
        layout.addWidget(self.stop_detect_button)

        self.status_label = QLabel("Status: Idle", self)
        layout.addWidget(self.status_label)

    def start_recording(self):
        if not self.data_collector or not self.data_collector.isRunning():
            self.data_collector = DataCollector(self.sampling_rate)
            self.data_collector.data_collected.connect(self.on_data_collected)
            self.data_collector.start()

    def stop_recording(self):
        if self.data_collector:
            self.data_collector.stop()
            self.data_collector.wait()

    def save_data(self):
        if self.eeg_data:
            options = QFileDialog.Options()
            file_name, _ = QFileDialog.getSaveFileName(self, "Save EEG Data", "", "JSON Files (*.json);;All Files (*)", options=options)
            if file_name:
                with open(file_name, 'w') as f:
                    json.dump(self.eeg_data.tolist(), f)

    def load_data(self):
        options = QFileDialog.Options()
        file_name, _ = QFileDialog.getOpenFileName(self, "Load EEG Data", "", "JSON Files (*.json);;All Files (*)", options=options)
        if file_name:
            with open(file_name, 'r') as f:
                self.eeg_data = np.array(json.load(f))
            self.plot_data()

    @pyqtSlot(np.ndarray)
    def on_data_collected(self, data):
        self.eeg_data = data
        self.plot_data()

    def plot_data(self):
        self.ax.clear()
        self.ax.plot(np.arange(len(self.eeg_data)) / self.sampling_rate, self.eeg_data)
        self.ax.set_xlabel("Time (s)")
        self.ax.set_ylabel("Amplitude")
        self.ax.set_title("EEG Data")
        self.canvas.draw()

    def label_start(self):
        x = plt.ginput(1)[0][0]
        self.labels.append((x, 'start'))
        print(f"Start labeled at {x} seconds")

    def label_end(self):
        x = plt.ginput(1)[0][0]
        self.labels.append((x, 'end'))
        print(f"End labeled at {x} seconds")

    def train_model(self):
        if not self.eeg_data:
            print("No data to train on.")
            return

        X = np.array([self.extract_features(sample) for sample in self.eeg_data])
        y = np.array([1 if label == 'start' else 0 for _, label in self.labels])

        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)
        self.model = RandomForestClassifier(n_estimators=100)
        self.model.fit(X_train, y_train)
        accuracy = self.model.score(X_test, y_test)
        print(f"Model Accuracy: {accuracy}")

    def start_real_time_detection(self):
        if not self.model:
            print("Model not trained. Please train the model first.")
            return

        self.status_label.setText("Status: Detecting...")
        self.real_time_detector = RealTimeDetector(self.model, self.sampling_rate)
        self.real_time_detector.detection_result.connect(self.on_detection_result)
        self.real_time_detector.start()

    def stop_real_time_detection(self):
        if hasattr(self, 'real_time_detector'):
            self.real_time_detector.stop()
            self.real_time_detector.wait()
            self.status_label.setText("Status: Idle")

    @pyqtSlot(str)
    def on_detection_result(self, result):
        self.status_label.setText(f"Status: {result}")

    def extract_features(self, data):
        filtered_data = self.bandpass_filter(data, 8, 12, self.sampling_rate)
        return np.mean(np.square(filtered_data))

    def bandpass_filter(self, data, lowcut, highcut, fs, order=5):
        nyquist = 0.5 * fs
        low = lowcut / nyquist
        high = highcut / nyquist
        b, a = butter(order, [low, high], btype='band')
        y = lfilter(b, a, data)
        return y

    def closeEvent(self, event):
        if hasattr(self, 'data_collector'):
            self.data_collector.stop()
            self.data_collector.wait()
        if hasattr(self, 'real_time_detector'):
            self.real_time_detector.stop()
            self.real_time_detector.wait()
        event.accept()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    main = InsultDetector()
    main.show()
    sys.exit(app.exec_())
